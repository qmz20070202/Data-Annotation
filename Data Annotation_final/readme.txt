手写汉字 OCR 标注工具 (Handwritten Chinese OCR Annotation Tool)
1. 项目目标 (Project Goal)
一句话概括：开发一个纯客户端的网页应用，让数据标注员能够高效地对图片中的手写文字进行识别、校准和标注，为内部 OCR 模型的训练提供高质量数据。

2. 核心用户故事 (Core User Story)
作为一名数据标注员，我希望能：

直接打开本地的图片文件夹，无需繁琐的上传步骤。

一键调用 OCR 服务，对文件夹内所有图片进行批量文字识别。

在界面左侧清晰地看到原始图片，以及 OCR 识别出的文字定位框。

在界面右侧看到与定位框一一对应的识别文本。

如果 OCR 漏掉了某些文字，我可以在左侧图片上手动绘制新的定位框。

如果 OCR 识别错了文字，我可以直接在右侧的文本框里进行修改。

当我完成一个文件夹的校对后，可以一键保存所有校准后的文本和坐标数据。

保存后，如果发现还有问题，可以随时重新进入**“校正模式”**进行二次修改。

3. 技术栈 (Tech Stack)
依据“化繁为简”和“依赖最小化”原则，我们选择最纯粹、对初学者最友好的技术栈。

HTML5: 负责应用的基本结构和骨架。

CSS3: 负责界面美化，我们将遵循苹果设计哲学，打造简洁、专业的视觉体验。

JavaScript (ES6+): 负责所有核心逻辑，包括文件读取、API 调用、Canvas 绘图和用户交互。

选择理由 (The "Why"):
这套组合是前端开发的基石。最重要的是，它不需要任何复杂的环境配置、编译或打包过程。您可以直接在浏览器中打开 index.html 文件开始开发和使用，这能让您最快地获得成就感，并专注于核心功能的实现，完美契合我们“用户至上”的第一原则。

我们将大量使用现代浏览器原生 API，如 File System Access API 来读取本地文件夹，Fetch API 来调用 OCR 服务，以及 Canvas API 来在图片上绘图。

4. 核心功能与实现思路 (Core Features & Implementation Plan)
4.1. 文件读取 (File Access)
目标: 让用户选择本地文件夹，并读取其中的所有图片文件。

实现方式: 使用现代浏览器的 File System Access API。

通过 window.showDirectoryPicker() 方法，可以弹出一个原生对话框让用户选择文件夹。

获取到文件夹句柄 (Directory Handle) 后，可以异步遍历其中的所有文件和子文件夹，递归查找，直到找到所有图片文件（如 .jpg, .png）。

将这些文件对象保存在一个 JavaScript 数组中，用于后续处理。

4.2. 图像识别流程 (OCR Workflow)
目标: 点击“识别”按钮，将文件列表中的图片发送给百度 OCR API，并获取结果。

实现方式:

用户点击“识别”按钮。

我们使用 Promise.all() 或 for...of 循环遍历图片文件列表。

对于每张图片，使用 fetch API 发起一个 POST 请求到您指定的百度 OCR 接口。请求体 (body) 通常是图片的 Base64 编码或二进制数据。

接收 API 返回的 JSON 数据（如您提供的 ex2.png 所示格式）。

将每张图片的识别结果（包含文字 text 和坐标 text_region）与对应的图片文件关联起来，存储在一个全局的状态对象中。

4.3. 标注界面 (Annotation UI)
目标: 实现左侧图片+标注框，右侧可编辑文本的联动视图。

实现方式:

布局: 采用 Flexbox 或 Grid 布局，轻松实现左右两栏结构。

左侧 (图像区):

使用一个 <img> 标签显示当前选中的原始图片。

在 <img> 标签的上方，覆盖一个同样大小的 <canvas> 元素，并设置其背景为透明。

渲染标注框 (What): 当 OCR 结果返回后，遍历结果中的 text_region 坐标。

如何实现 (How): 使用 Canvas 的 2D 上下文 (getContext('2d'))，根据坐标点调用 beginPath(), moveTo(), lineTo(), 和 stroke() 方法，在 <canvas> 上绘制出多边形或矩形框。

右侧 (文本区):

根据 OCR 返回的每一条文字结果，动态创建一组 HTML 元素，例如一个 div 容器，里面包含一个 <textarea> (用于编辑文字) 和一个序号。

<textarea> 的内容默认为 OCR 识别出的 text。

4.4. 交互式标注与校正 (Interactive Annotation & Correction)
目标: 允许用户手动绘制新框，并修改已有文本。

实现方式:

手动绘制新框:

在左侧的 <canvas> 上监听鼠标事件 (mousedown, mousemove, mouseup)。

mousedown: 记录起始点坐标，设置一个 isDrawing 标志为 true。

mousemove: 如果 isDrawing 为 true，实时获取当前鼠标位置，并清除上一帧绘制的矩形、绘制一个新的矩形（从起始点到当前点），给用户实时的视觉反馈。

mouseup: 记录结束点坐标，isDrawing 设为 false。此时一个新框宣告绘制完成。我们将这个新框的坐标存入数据，并在右侧生成一个新的、空的 <textarea> 等待用户输入文字。

修改文本: 右侧的 <textarea> 默认就是可编辑的，这部分无需特殊处理。

联动高亮 (提升体验): 当鼠标悬浮在左侧某个标注框上时，右侧对应的文本框可以添加一个高亮边框；反之，当用户聚焦于右侧某个文本框时，左侧对应的标注框也可以高亮。这可以通过为每个框和文本区添加相同的 data-id 属性来实现。

4.5. 数据保存 (Data Persistence)
目标: 将用户校准后的所有数据保存下来。

实现方式:

数据结构: 将所有校准后的数据整理成一个清晰的 JSON 结构。这个结构应该能清晰地反映文件夹、图片、以及每张图片对应的标注信息（文字和坐标）。

保存动作: 用户点击“保存”按钮后，将这个 JSON 对象转换为字符串 (JSON.stringify)。

触发下载: 创建一个 <a> 标签，将其 href 设置为 URL.createObjectURL(new Blob([jsonString], {type: "application/json"}))，并设置 download 属性（例如 annotations.json），然后用 JavaScript 模拟点击这个链接，即可触发浏览器下载保存这个 JSON 文件。

5. 项目结构 (Project Structure)
为了保持清晰和可维护性，我们采用经典的模块化结构。

/ocr-annotation-tool
|
|-- index.html              # 项目唯一的 HTML 入口文件
|-- README.md               # 项目说明文档 (就是本文件)
|
|-- /css
|   |-- style.css           # 唯一的样式文件
|
|-- /js
|   |-- main.js             # 主逻辑文件，负责初始化和协调其他模块
|   |-- ui.js               # 负责所有 DOM 操作，如创建文本框、更新列表等
|   |-- canvas.js           # 封装所有 Canvas 绘图和交互逻辑
|   |-- api.js              # 封装对百度 OCR API 的调用逻辑
|
|-- /assets
    |-- /icons/             # 存放可能用到的 SVG 图标 (如“识别”、“保存”等)
拆分原因 (The "Why"): 将不同功能的代码分到不同文件（关注点分离），能让项目在未来功能增加时依然保持整洁，易于理解和修改。

6. 如何运行 (How to Run)
将本项目所有文件下载或克隆到本地。

在现代浏览器（推荐 Chrome 或 Edge 最新版）中，直接打开 index.html 文件。

点击页面上的“选择文件夹”按钮，选择您要标注的图片文件夹。

开始您的标注工作。

7. 下一步：前瞻与迭代 (Next Steps: Vision & Iteration)
一个好的项目永远在进化。完成核心功能后，我们可以从以下方向进行优化，这也是我作为架构师为您指明的成长路径：

效率提升：快捷键与批量操作

建议: 为高频操作（如保存、切换到下一张图片、创建新框体）增加键盘快捷键（例如 Ctrl+S 保存，方向键 → ← 切换图片）。这将极大提升标注员的工作效率。

实现: 在 main.js 中监听全局的 keydown 事件。

数据健壮性：引入项目文件

建议: 在“保存”时，除了生成可下载的 JSON，还可以将这份 JSON 自动保存在用户选择的文件夹内（同样使用 File System Access API 的写入权限）。当用户下次打开同一个文件夹时，程序可以自动检测并加载这个 annotations.json 文件，恢复上次的工作进度。

实现: 扩展文件读取逻辑，增加对 annotations.json 的检测。

8. 潜在风险与调试思路 (Debugging Partner)
开发过程中可能会遇到一些问题，提前预知可以让我们从容应对：

常见错误1：API 跨域问题 (CORS)

现象: 在浏览器控制台看到关于 CORS policy 的错误。

调试思路: 由于我们是纯客户端应用，调用百度 API 可能会遇到跨域限制。解决方案通常是在百度云控制台配置允许您的来源（如果是本地开发，通常是 null 或 localhost），或者在开发阶段使用浏览器插件暂时禁用跨域限制。但最终的生产级解决方案需要后端服务器进行代理转发。 (这是我们目前选择纯客户端方案的一个潜在权衡)。

常见错误2：坐标系不匹配

现象: 绘制的标注框位置与图片上的实际位置有偏差。

调试思路: 务必确保 <canvas> 的尺寸与 <img> 的渲染后尺寸完全一致。如果图片被 CSS 缩放了，那么在 Canvas 上绘图时，需要将从 API 获取的原始坐标按同样的比例进行缩放。例如：canvasX = originalX * (img.clientWidth / img.naturalWidth)。

这份 README.md 为您的项目奠定了坚实的基础。请以此为纲领，开启您的开发之旅。如果您在实现过程中遇到任何具体的技术难题，我随时准备为您提供更深入的指导和代码片段。